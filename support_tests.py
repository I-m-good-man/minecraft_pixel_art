import pyautogui
import PIL
from PIL import Image


string = """
dict_with_coordinates_in_menu = {'roll_in_necessary_place': (1289, 766), 'белый': (853, 442), 'оранжевый': (923, 443),
                                 'пурпурный': (996, 442), 'коричневый': (1068, 515), 'темно-зеленый': (1141, 515),
                              'голубой': (1068, 444), 'желтый': (1139, 443), 'зеленый': (1213, 442),
                              'розовый': (635, 513), 'темно-красный': (1212, 514),'черный': (636, 585),
                              'темно-серый': (708, 515), 'светло-серый': (780, 515),
                              'бирюзовый': (853, 515), 'фиолетовый': (924, 514), 'синий': (995, 513)
                              }
"""


def work_with_img(file_name):
    """
    Эта функция принимает на вход имя файла. Функция переводит фотографию в меньшее разрешения, чтобы получить пиксельный
    эффект. Функция возвращает объект, из которого можно получить цветовое значения каждого пикселя уменьшенной
    фотографии и разрешение этой фотографии.
    :param file_name:
    :return: img_obj, new_width, new_height
    """
    rgb2xyz = (
        0.412453, 0.357580, 0.180423, 0,
        0.212671, 0.715160, 0.072169, 0,
        0.019334, 0.119193, 0.950227, 0)
    # открываем фото
    try:
        img = Image.open(f'./images/{file_name}').convert('HSV')
    except OSError:
        raise OSError
    # получаем размеры в пикселях нашего фото
    width, height = img.size
    # размер пикселя
    size_of_pixel = 16
    # создаем новые размеры фото
    new_width, new_height = width // (height // size_of_pixel), size_of_pixel
    reduce_img = img.resize((new_width, new_height))
    img_obj = reduce_img.load()
    print(img_obj[0, 1])

    reduce_img.convert('RGB')
    img_obj = reduce_img.load()
    print(img_obj[0, 1])
    return img_obj, new_width, new_height


work_with_img('tagir.bmp')
def determine_blocks_for_pixels(all_pixels, width, height):
    """
    Эта функция определяет, какого цвета нужно взять блок. Выборка осуществляется на основании цвета текущего пикселя.
    Функция вернет двумерный массив, список списков, каждый список - это столбец цветов, которые нужно ставить снизу-вверх.
    :return:
    """
    def determine_color(color_of_pixel):
        """
        Эта функция сверяет цвет пикслея, который она получает на входе, с цветом, которые имеют блоки в словаре
        dict_with_colors_of_blocks. Чтобы узнать, какой блок соответствует по цвету пикселю, мы будем сравнивать суммы
        значений ргб пикселя и значений ргб блока.
        :return:
        """
        dict_with_colors_of_blocks = {'белый': (206, 212, 213), 'оранжевый': (225, 98, 1), 'пурпурный': (169, 48, 159),
                                      'голубой': (35, 137, 199), 'желтый': (242, 176, 21), 'зеленый': (95, 170, 25),
                                      'розовый': (212, 100, 142), 'темно-красный': (141, 32, 32),
                                      'черный': (9, 11, 16),
                                      'темно-серый': (54, 57, 61), 'светло-серый': (126, 126, 116),
                                      'бирюзовый': (22, 120, 137),'фиолетовый': (100, 31, 156), 'синий': (44, 46, 143),
                                      'коричневый': (97, 61, 33),'темно-зеленый': (73, 91, 36)
                                      }

        # это словарь с суммами разности
        dict_with_sums = {}

        for key, value in dict_with_colors_of_blocks.items():
            # тут мы добавляем в словарь модуль разности двух сум, чем ближе это значение к нулю, тем больше цвет
            # пикселя подходит к цвету блока
            dict_with_sums[key] = abs(sum(value) - sum(color_of_pixel))

        # список с кортежами, в которых ключ и значение
        list_with_keys_and_values = list(dict_with_sums.items())

        # сортируем список, ключ находится на 0 позиции в кортеже, значение на 1
        sorted_list_with_keys_and_values = sorted(list_with_keys_and_values, key=lambda x: x[1])

        # т.к. нам нужно наименьшее значение, то мы забираем цвет первого элемента списка
        necessary_color = sorted_list_with_keys_and_values[0][0]
        return necessary_color

    # это список со списками, в котором идут столбцы по порядку снизу вверх
    list_for_colors = []

    # это словарь, в котором подсчитывается количество блоков каждого цвета, чтобы можно было найти 8 наиболее частых блоков
    dict_counter = {'белый': 0, 'оранжевый': 0, 'пурпурный': 0,
                                      'голубой': 0, 'желтый': 0, 'зеленый': 0,
                                      'розовый': 0, 'темно-красный': 0,
                                      'черный': 0,
                                      'темно-серый': 0, 'светло-серый': 0,
                                      'бирюзовый': 0,'фиолетовый': 0, 'синий': 0,
                                      'коричневый': 0,'темно-зеленый': 0}

    # тут перебираются номера столбцов
    for w in range(width):
        # это список для цветов каждой ячейки столбца
        current_column = []
        # тут перебираются значения ячейки каждого столбца снизу вверх
        for h in range(height):
            color_of_block = determine_color(all_pixels[w, h])
            # добавляем в список цвет блока, сопоставленный с цветом пикселя в функции determine_color
            current_column.append(color_of_block)
            # увеличиваем на один счетчик цветов
            dict_counter[color_of_block] += 1
        list_for_colors.append(current_column)

    # сортируем словарь с кол-вом каждого цвета и получаем отсортированный список кортежей
    dict_counter = sorted(list(dict_counter.items()), key=lambda el: el[1], reverse=True)
    # составляем список с 8 основными цветами
    main_colors = [el[0] for el in dict_counter[:8]]
    return list_for_colors, main_colors
